import numpy as np
import matplotlib.pyplot as plt
import matplotlib
# import scipy
import sys
sys.path.append('../../quaternion_integrator')

from quaternion import Quaternion


def centerDist(x1,x2):
    " Center center distance for the particles"
    return np.linalg.norm(x1-x2)


def quaternion_to_rotation_matrix(q):
    """
    This function returns the rotation matrix that rotates the input unit quaternion 'q' to the quaternion [1 0 0 0].

    Parameters:
    q (numpy array): A numpy array of shape (4,) representing a unit quaternion

    Returns:
    numpy array: A numpy array of shape (3,3) representing the rotation matrix
    """
    q = np.array(q)
    assert q.shape == (4,), "Input should be a numpy array of shape (4,)"
    assert np.isclose(np.linalg.norm(q), 1.0), "Input quaternion should be a unit quaternion"

    R = np.zeros((3,3))
    q0, q1, q2, q3 = q
    R[0,0] = 1 - 2*q2**2 - 2*q3**2
    R[0,1] = 2*q1*q2 - 2*q0*q3
    R[0,2] = 2*q1*q3 + 2*q0*q2
    R[1,0] = 2*q1*q2 + 2*q0*q3
    R[1,1] = 1 - 2*q1**2 - 2*q3**2
    R[1,2] = 2*q2*q3 - 2*q0*q1
    R[2,0] = 2*q1*q3 - 2*q0*q2
    R[2,1] = 2*q2*q3 + 2*q0*q1
    R[2,2] = 1 - 2*q1**2 - 2*q2**2

    return R

def rotate_quaternion(q1, q2):
    """
    This function rotates the second quaternion 'q2' so that the first quaternion 'q1' coincides with [1 0 0 0].

    Parameters:
    q1 (numpy array): A numpy array of shape (4,) representing a unit quaternion
    q2 (numpy array): A numpy array of shape (4,) representing a unit quaternion

    Returns:
    numpy array: A numpy array of shape (4,) representing the rotated quaternion
    """
    q1 = np.array(q1)
    q2 = np.array(q2)
    assert q1.shape == (4,) and q2.shape == (4,), "Inputs should be numpy arrays of shape (4,)"
    assert np.isclose(np.linalg.norm(q1), 1.0) and np.isclose(np.linalg.norm(q2), 1.0), "Inputs should be unit quaternions"

    # Compute the rotation matrix
    R = quaternion_to_rotation_matrix(q1)

    # Rotate the second quaternion
    q2_rotated = R @ q2

    return q2_rotated


def spherical_coordinates(q, L):
    """
    This function takes a quaternion 'q' and a length 'L' as input and returns the spherical coordinates for the line
    segment specified by the direction of the quaternion 'q' and length 'L'.

    Parameters:
    q (numpy array): A numpy array of shape (4,) representing a unit quaternion that specifies the direction of the line segment
    L (float): A float representing the length of the line segment

    Returns:
    tuple: A tuple of two floats (r, theta) representing the spherical coordinates of the line segment, where 'r' is the
           radial distance and 'theta' is the polar angle in radians.
    """
    q = np.array(q)
    assert q.shape == (4,), "Input quaternion should be a numpy array of shape (4,)"
    assert np.isclose(np.linalg.norm(q), 1.0), "Input quaternion should be a unit quaternion"

    # Extract the direction vector from the quaternion
    v = q[1:]

    # Convert the direction vector to spherical coordinates
    r = L
    theta = np.arccos(v[2] / np.linalg.norm(v))

    if np.isclose(np.linalg.norm(v[:2]), 0.0):
        phi = 0.0
    else:
        phi = np.arctan2(v[1], v[0])

    return r, theta, phi

def spherical_q2(q1,q2):
    q2_rotated = rotate_quaternion(q1, q2,L)

    #Hmm... should I also rotate here so that the center coordinates are in the same plane, more explicitly?
    return spherical_coordinates(q2_rotated,L)



#place in main file

#test first to rotate q by the matrix generated by q above


filename =
numSteps = 1000 # number of MCMC runs
L = 0.5 #particle lenght


with open(filename, 'r') as file:
for i, line in enumerate(file):
    l =[]
    if i % 3 == 1:
        # Extract coodinates for particle 1
        for t in line.spit():
            l.append(float(t))
        q1 = Quaternion(np.array(l[3:])) #this is the quaternion for the particle. Now, turn it into a direction vector
        x1 = np.array(l[0:3])
    elif i % 3 == 2:
        #extract coordinate and quaternion for particle 2
        for t in line.spit():
            l.append(float(t))
        q2 = Quaternion(np.array(l[3:])) #this is the quaternion for the particle. Now, turn it into a direction vector
        x2 = np.array(l[0:3])
    elif i>2:
        #compute statistics using these coordinates
        ccDist[i/3-1] = centerDist(x1,x2)
        shortetDist[i/3-1] =
        alphaDist[i/3-1] =

        phiDist[i/3-1]
        thetaDist[i/3-1]
